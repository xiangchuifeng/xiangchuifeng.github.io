

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>王的宇</title>
  <subtitle>frontend, 一个前端开发技术总结的博客.</subtitle>
  <updated>2023-05-26T17:17:03+08:00</updated>
  <author>
    <name>xiangchuifeng</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh-CN"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 xiangchuifeng </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>naive-ui中Anchor点击侧边栏锚点时候却跳转新页面的解决</title>
    <link href="/posts/naive-ui%E4%B8%ADAnchor%E7%82%B9%E5%87%BB%E9%94%9A%E7%82%B9%E6%97%B6%E5%80%99%E5%8D%B4%E8%B7%B3%E8%BD%AC%E6%96%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%A7%A3%E5%86%B3/" rel="alternate" type="text/html" title="naive-ui中Anchor点击侧边栏锚点时候却跳转新页面的解决" />
    <published>2023-05-22T10:26:00+08:00</published>
  
    <updated>2023-05-22T10:26:00+08:00</updated>
  
    <id>/posts/naive-ui%E4%B8%ADAnchor%E7%82%B9%E5%87%BB%E9%94%9A%E7%82%B9%E6%97%B6%E5%80%99%E5%8D%B4%E8%B7%B3%E8%BD%AC%E6%96%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <content src="/posts/naive-ui%E4%B8%ADAnchor%E7%82%B9%E5%87%BB%E9%94%9A%E7%82%B9%E6%97%B6%E5%80%99%E5%8D%B4%E8%B7%B3%E8%BD%AC%E6%96%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%A7%A3%E5%86%B3/" />
    <author>
      <name>xiangchuifeng</name>
    </author>

  
    
    <category term="ui组件库问题解决" />
    
    <category term="naive-ui" />
    
  

  
    <summary>
      





      naive-ui中Anchor点击侧边栏导航锚点跳转，却是新页面的问题；

最近开发过程用 有使用锚点定位跳转的功能，于是使用了naive-ui的Anchor组件，组件demo代码 套用到项目上的时候，右侧内容滚动时候，侧边栏的锚点会
自动高亮，这个是没有问题的，然后问题来了，点击左边锚点时候，右边的页面不会定向到对应位置，而是跳转了新页面，因为vue-router路由模式把锚点定位
理解成了新页面的跳转。

再回头看了一下 naive-ui组件说明，它是提供的有组件方法的，scrollTo,但是点击事件直接是默认的组件里面的a链接跳转，跳珠到了新页面。
终于在思考了片刻之后，想到组件上使用点击事件加vue指令的修饰符应该是可以解决的。

于是最终解决方案如下：

&amp;lt;n-anchor
  ref="anchorRef"
  :show-rail="showRail"
  :sh...
    </summary>
  

  </entry>

  
  <entry>
    <title>js设计模式-方法的链式调用</title>
    <link href="/posts/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%96%B9%E6%B3%95%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" rel="alternate" type="text/html" title="js设计模式-方法的链式调用" />
    <published>2023-05-12T17:02:00+08:00</published>
  
    <updated>2023-05-12T17:02:00+08:00</updated>
  
    <id>/posts/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%96%B9%E6%B3%95%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</id>
    <content src="/posts/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%96%B9%E6%B3%95%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" />
    <author>
      <name>xiangchuifeng</name>
    </author>

  
    
    <category term="js设计模式理解" />
    
  

  
    <summary>
      





      链式调用

链式调用是简单来讲就是 一个对象/主体 调用的方法，可以返回主体本身，可以接着去访问主体的下一个方法或者操作 ,它是一种语法招数。


  用一天的时间，抽空看完一种设计模式，或者两天，还是有收获的，我们需要耐心，这个从长远来说，不算慢的。


// 大概这个意思
function b(dataIn) {
  // ...
  return dataIn;
}


链式调用可以让代码的可读性更好，代码结构更清晰，易读， 减少了代码量。如下所示对比：


  baby.read();
  baby.write();
  baby.eatFood();
  baby.sleep();

  baby.read().write().eatFood().sleep()......



a.b().c()
比如我们以前用的 jquery.js,就是用的链式调用。

$("div"...
    </summary>
  

  </entry>

  
  <entry>
    <title>js设计模式-单体模式</title>
    <link href="/posts/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BD%93%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="js设计模式-单体模式" />
    <published>2023-05-11T11:49:00+08:00</published>
  
    <updated>2023-05-11T11:49:00+08:00</updated>
  
    <id>/posts/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BD%93%E6%A8%A1%E5%BC%8F/</id>
    <content src="/posts/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BD%93%E6%A8%A1%E5%BC%8F/" />
    <author>
      <name>xiangchuifeng</name>
    </author>

  
    
    <category term="js设计模式理解" />
    
  

  
    <summary>
      





      单体模式

单你（singleton）模式是 javascript 中最基本但又最有用的模式之一，这种模式提供了一种将代码组织为一个逻辑单元的手段，这个逻辑单元中的代码可以通过单一的变最进行访问。通过确保单体对象只存在一份实例，你就可以确信自己的所有代码使用的都是同样的全局资源.借助于单体模式，你可以把代码组织得更为一致，从而使其更容易阅读和维护。

这种模式在 JavaScript 中非常重要，也许比在其他任何语言中都更重要。在网页上使用全局变量有很大的风险，而用单体对象创建的命名空间则是清除这些全局变量的最佳手段之一，他们可以划分命名空间，清除减少全局的变量数目，


  用一天的时间，抽空看完一种设计模式，或者两天，还是有收获的，我们需要耐心，这个从长远来说，不算慢的。


一个比较基本的单体结构如下

const singleton = {
  attribute1: tru...
    </summary>
  

  </entry>

  
  <entry>
    <title>富文本中的图片是base64的，导致提交数据很大，接口响应很慢</title>
    <link href="/posts/%E5%AF%8C%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%98%AFbase64%E7%9A%84-%E5%AF%BC%E8%87%B4%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E5%BE%88%E5%A4%A7-%E5%93%8D%E5%BA%94%E5%BE%88%E6%85%A2/" rel="alternate" type="text/html" title="富文本中的图片是base64的，导致提交数据很大，接口响应很慢" />
    <published>2023-04-28T16:37:00+08:00</published>
  
    <updated>2023-04-28T16:37:00+08:00</updated>
  
    <id>/posts/%E5%AF%8C%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%98%AFbase64%E7%9A%84-%E5%AF%BC%E8%87%B4%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E5%BE%88%E5%A4%A7-%E5%93%8D%E5%BA%94%E5%BE%88%E6%85%A2/</id>
    <content src="/posts/%E5%AF%8C%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%98%AFbase64%E7%9A%84-%E5%AF%BC%E8%87%B4%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E5%BE%88%E5%A4%A7-%E5%93%8D%E5%BA%94%E5%BE%88%E6%85%A2/" />
    <author>
      <name>xiangchuifeng</name>
    </author>

  
    
    <category term="工作中的问题" />
    
  

  
    <summary>
      





      富文本中的图片是base64的，导致提交数据很大，接口响应很慢
富文本编辑器 图片base64太长问题
前端开发人员在遇到富文本编辑器的时候，经常会被测试 或者产品提各种需求优化或者一些体验的bug ;


比如：


  测试会提出富文本的内容过长，限制内容，限制输入等等类似的问题： 其实为什么是富文本，就是要写文章用的，这个用户行为，是不建议给限制的。 那么测试会提 内容太长，限制字数的问题，不用想，限制不了的，字数是不准确的，包括了html标签，特殊符号等等,或者会说可以使用获取text content 等各个富文本组件对应的api。但是这个只是限制了text 或者content的长度，无法限制html string 的总长度的。
  —&amp;gt; 所以直白的结论是，这个限制富文本长度，富文本限制输入的问题，90% 不是问题，就是这样的，不用解决！或者限制一个极限最大长度，但这个...
    </summary>
  

  </entry>

  
  <entry>
    <title>VSCode 中组件输入点击事件 @click 后自动弹出“$event =＞”</title>
    <link href="/posts/VSCode-%E4%B8%AD%E7%BB%84%E4%BB%B6%E8%BE%93%E5%85%A5%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6-@click-%E5%90%8E%E8%87%AA%E5%8A%A8%E5%BC%B9%E5%87%BA-$event-=/" rel="alternate" type="text/html" title="VSCode 中组件输入点击事件 @click 后自动弹出“$event =＞”" />
    <published>2023-04-21T10:48:00+08:00</published>
  
    <updated>2023-04-21T10:48:00+08:00</updated>
  
    <id>/posts/VSCode-%E4%B8%AD%E7%BB%84%E4%BB%B6%E8%BE%93%E5%85%A5%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6-@click-%E5%90%8E%E8%87%AA%E5%8A%A8%E5%BC%B9%E5%87%BA-$event-=/</id>
    <content src="/posts/VSCode-%E4%B8%AD%E7%BB%84%E4%BB%B6%E8%BE%93%E5%85%A5%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6-@click-%E5%90%8E%E8%87%AA%E5%8A%A8%E5%BC%B9%E5%87%BA-$event-=/" />
    <author>
      <name>xiangchuifeng</name>
    </author>

  
    
    <category term="工具、环境" />
    
  

  
    <summary>
      





      在 Vue 中的点击事件 @click 后会自动补全一段“$event =&amp;gt;”，这是 VSCode 中setting.json未设置好的缘故，具体情况如下：
  

如上图所示：“@click=”后面自动补全“$event =&amp;gt;”

这时候 操作 ctrl+shift+p ,搜索 setting.json打开 setting.json 文件并修改以下代码即可

{
  "editor.inlayHints.enabled":"offUnlessPressed"
}


若没有该行代码,对应添加进去就可以了

    </summary>
  

  </entry>

</feed>


